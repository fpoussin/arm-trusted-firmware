/* SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause) */
/*
 * Copyright (C) STMicroelectronics 2021 - All Rights Reserved
 * Author: STM32CubeMX code generation for STMicroelectronics.
 */

/* For more information on Device Tree configuration, please refer to
 * https://wiki.st.com/stm32mpu/wiki/Category:Device_tree_configuration
 */

/dts-v1/;
#include <dt-bindings/pinctrl/stm32-pinfunc.h>
#include <dt-bindings/clock/stm32mp1-clksrc.h>
#include <dt-bindings/soc/st,stm32-etzpc.h>
#include "stm32mp15-mx.dtsi"

#include "stm32mp153.dtsi"
#include "stm32mp15xa.dtsi"
#include "stm32mp15xxab-pinctrl.dtsi"
#include "stm32mp15-ddr.dtsi"

/* USER CODE BEGIN includes */
#include <dt-bindings/power/stm32mp1-power.h>
/* USER CODE END includes */

/ {
	model = "RaceBytes Core1 v0.1";
	compatible = "st,stm32mp153a-mp1-rev-0.1-mx", "st,stm32mp153";

	/* USER CODE BEGIN root */
	aliases {
		mmc0 = &sdmmc1;
		serial0 = &uart4;
	};

	chosen {
		stdout-path = "serial0:115200n8";
	};

	vin: vin {
		compatible = "regulator-fixed";
		regulator-name = "vin";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		regulator-always-on;
	};

	reg_3v3: reg_3v3 {
		compatible = "regulator-fixed";
		regulator-name = "3v3";
		regulator-min-microvolt = <3120000>;
		regulator-max-microvolt = <3120000>;
		regulator-always-on;
		vin-supply = <&vin>;
	};

	reg_vdd: reg_vdd {
		compatible = "regulator-fixed";
		regulator-name = "vdd";
		regulator-min-microvolt = <3000000>;
		regulator-max-microvolt = <3000000>;
		regulator-always-on;
		vin-supply = <&vin>;
	};

	reg_vddcore: reg_vddcore {
		compatible = "regulator-fixed";
		regulator-name = "vddcore";
		regulator-min-microvolt = <1320000>;
		regulator-max-microvolt = <1320000>;
		regulator-always-on;
		vin-supply = <&reg_3v3>;
	};

	led-act {
		compatible = "gpio-leds";

		led-green {
		label = "core1:green:act";
		gpios = <&gpiod 11 0>;
		linux,default-trigger = "heartbeat";
		};
	};
	/* USER CODE END root */

	clocks {
		/* USER CODE BEGIN clocks */
		/* USER CODE END clocks */

		clk_lse: clk-lse {
			st,drive = < LSEDRV_MEDIUM_LOW >;

			/* USER CODE BEGIN clk_lse */
			/* USER CODE END clk_lse */
		};

		clk_hse: clk-hse {

			/* USER CODE BEGIN clk_hse */
			/* USER CODE END clk_hse */
		};
	};

}; /*root*/

&pinctrl {
	rcc_pins_mx: rcc_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('A', 8, AF0)>; /* RCC_MCO_1 */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	sdmmc1_pins_mx: sdmmc1_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('C', 8, AF12)>, /* SDMMC1_D0 */
					 <STM32_PINMUX('C', 9, AF12)>, /* SDMMC1_D1 */
					 <STM32_PINMUX('C', 10, AF12)>, /* SDMMC1_D2 */
					 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
					 <STM32_PINMUX('D', 2, AF12)>; /* SDMMC1_CMD */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
			bias-pull-up;
			drive-push-pull;
			slew-rate = <3>;
		};
	};

	uart4_pins_mx: uart4_mx-0 {
		pins1 {
			pinmux = <STM32_PINMUX('D', 0, AF8)>; /* UART4_RX */
			bias-pull-up;
		};
		pins2 {
			pinmux = <STM32_PINMUX('D', 1, AF8)>; /* UART4_TX */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	usb_otg_hs_pins_mx: usb_otg_hs_mx-0 {
		pins {
			pinmux = <STM32_PINMUX('A', 10, ANALOG)>; /* USB_OTG_HS_ID */
		};
	};

	/* USER CODE BEGIN pinctrl */
	/* USER CODE END pinctrl */
};

&pinctrl_z {
	/* USER CODE BEGIN pinctrl_z */
	/* USER CODE END pinctrl_z */
};

&rcc {
	st,csi-cal;
	st,hsi-cal;
	st,cal-sec = <60>;
	st,clksrc = <
		CLK_MPU_PLL1P
		CLK_AXI_PLL2P
		CLK_MCU_PLL3P
		CLK_PLL12_HSE
		CLK_PLL3_HSE
		CLK_PLL4_HSE
		CLK_RTC_LSE
		CLK_MCO1_LSE
		CLK_MCO2_DISABLED
	>;
	st,clkdiv = <
		1 		/*MPU*/
		0 		/*AXI*/
		0 		/*MCU*/
		1 		/*APB1*/
		1 		/*APB2*/
		1 		/*APB3*/
		1 		/*APB4*/
		2 		/*APB5*/
		63 		/*RTC*/
		0 		/*MCO1*/
		0 		/*MCO2*/
	>;
	st,pkcs = <
		CLK_CKPER_HSE
		CLK_ETH_DISABLED
		CLK_SDMMC12_PLL4P
		CLK_STGEN_HSE
		CLK_USBPHY_HSE
		CLK_SPI2S1_DISABLED
		CLK_SPI2S23_DISABLED
		CLK_SPI45_DISABLED
		CLK_SPI6_DISABLED
		CLK_I2C46_DISABLED
		CLK_SDMMC3_DISABLED
		CLK_USBO_USBPHY
		CLK_ADC_CKPER
		CLK_CEC_DISABLED
		CLK_I2C12_DISABLED
		CLK_I2C35_DISABLED
		CLK_UART1_DISABLED
		CLK_UART24_HSE
		CLK_UART35_DISABLED
		CLK_UART6_DISABLED
		CLK_UART78_HSE
		CLK_SPDIF_DISABLED
		CLK_FDCAN_PLL4R
		CLK_SAI1_DISABLED
		CLK_SAI2_DISABLED
		CLK_SAI3_DISABLED
		CLK_SAI4_DISABLED
		CLK_RNG1_CSI
		CLK_LPTIM1_DISABLED
		CLK_LPTIM23_DISABLED
		CLK_LPTIM45_DISABLED
	>;
	pll1:st,pll@0 {
		compatible = "st,stm32mp1-pll";
		reg = <0>;
		cfg = < 1 53 0 1 1 PQR(1,0,0) >;
	};
	pll2:st,pll@1 {
		compatible = "st,stm32mp1-pll";
		reg = <1>;
		cfg = < 2 65 1 1 0 PQR(1,0,1) >;
	};
	pll3:st,pll@2 {
		compatible = "st,stm32mp1-pll";
		reg = <2>;
		cfg = < 2 51 1 12 3 PQR(1,0,0) >;
	};
	pll4:st,pll@3 {
		compatible = "st,stm32mp1-pll";
		reg = <3>;
		cfg = < 2 99 7 19 7 PQR(1,0,1) >;
	};
};

&bsec{
	status = "okay";
	secure-status = "okay";

	/* USER CODE BEGIN bsec */
	board_id: board_id@ec {
		reg = <0xec 0x4>;
		st,non-secure-otp;
	};
	/* USER CODE END bsec */
};

&etzpc{
	st,decprot = <
	/*"Non Secured" peripherals*/
	DECPROT(STM32MP1_ETZPC_ADC_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_DMA1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_DMA2_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_DMAMUX_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_TT_FDCAN_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_HASH1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_RNG1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_UART4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_UART8_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_OTG_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_VREFBUF_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	/*"NS_R S_W" peripherals*/
	DECPROT(STM32MP1_ETZPC_DDRCTRL_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
	DECPROT(STM32MP1_ETZPC_DDRPHYC_ID, DECPROT_NS_R_S_W, DECPROT_LOCK)
	/*"Secured" peripherals*/
	DECPROT(STM32MP1_ETZPC_IWDG1_ID, DECPROT_S_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_STGENC_ID, DECPROT_S_RW, DECPROT_UNLOCK)
	/*"Mcu Isolation" peripherals*/
	DECPROT(STM32MP1_ETZPC_UART7_ID, DECPROT_MCU_ISOLATION, DECPROT_UNLOCK)

	/*Restriction: following IDs are not managed  - please to use User-Section if needed:
		STM32MP1_ETZPC_SRAMx_ID, STM32MP1_ETZPC_RETRAM_ID, STM32MP1_ETZPC_BKPSRAM_ID*/

	/* USER CODE BEGIN etzpc_decprot */
	DECPROT(STM32MP1_ETZPC_BKPSRAM_ID, DECPROT_S_RW, DECPROT_LOCK)

	/* Clear warning messages "ETZPC: xxx could be non secure" */
	DECPROT(STM32MP1_ETZPC_USART1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_SPI6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_I2C4_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_I2C6_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	DECPROT(STM32MP1_ETZPC_CRYP1_ID, DECPROT_NS_RW, DECPROT_UNLOCK)
	/* USER CODE END etzpc_decprot */
	>;

	secure-status = "okay";

	/* USER CODE BEGIN etzpc */
	/* USER CODE END etzpc */
};

&iwdg1{
	secure-status = "okay";

	/* USER CODE BEGIN iwdg1 */
	/* USER CODE END iwdg1 */
};

&iwdg2{
	status = "okay";
	secure-status = "okay";

	/* USER CODE BEGIN iwdg2 */
	timeout-sec = <32>;
	secure-timeout-sec = <5>;
	/* USER CODE END iwdg2 */
};

&pwr_regulators{
	status = "okay";
	secure-status = "okay";

	/* USER CODE BEGIN pwr_regulators */
	system_suspend_supported_soc_modes = <
		STM32_PM_CSLEEP_RUN
		STM32_PM_CSTOP_ALLOW_LP_STOP
		STM32_PM_CSTOP_ALLOW_STANDBY_DDR_SR
	>;
	system_off_soc_mode = <STM32_PM_CSTOP_ALLOW_STANDBY_DDR_OFF>;
	/* USER CODE END pwr_regulators */
};

&rcc{
	pinctrl-names = "default";
	pinctrl-0 = <&rcc_pins_mx>;
	status = "okay";
	secure-status = "okay";

	/* USER CODE BEGIN rcc */
	/* USER CODE END rcc */
};

&rng1{
	status = "okay";
	secure-status = "okay";

	/* USER CODE BEGIN rng1 */
	/* USER CODE END rng1 */
};

&rtc{
	status = "okay";
	secure-status = "okay";

	/* USER CODE BEGIN rtc */
	/* USER CODE END rtc */
};

&sdmmc1{
	pinctrl-names = "default";
	pinctrl-0 = <&sdmmc1_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN sdmmc1 */
	bus-width = <4>;
	non-removable;
	disable-wp;

	st,neg-edge;
	max-frequency = <50000000>;
	
	vmmc-supply = <&reg_3v3>;
	vqmmc-supply = <&reg_vdd>;
	/* USER CODE END sdmmc1 */
};

&tamp{
	status = "okay";
	secure-status = "okay";

	/* USER CODE BEGIN tamp */
	/* USER CODE END tamp */
};

&uart4{
	pinctrl-names = "default";
	pinctrl-0 = <&uart4_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN uart4 */
	/* USER CODE END uart4 */
};

&usbotg_hs{
	pinctrl-names = "default";
	pinctrl-0 = <&usb_otg_hs_pins_mx>;
	status = "okay";

	/* USER CODE BEGIN usbotg_hs */
	/* USER CODE END usbotg_hs */
};

&usbphyc{
	status = "okay";

	/* USER CODE BEGIN usbphyc */
	/* USER CODE END usbphyc */
};

&usbphyc_port0{
	status = "okay";

	/* USER CODE BEGIN usbphyc_port0 */
	/* USER CODE END usbphyc_port0 */
};

&usbphyc_port1{
	status = "okay";

	/* USER CODE BEGIN usbphyc_port1 */
	/* USER CODE END usbphyc_port1 */
};

/* USER CODE BEGIN addons */
// gpio-poweroff {
// 	compatible = "gpio-poweroff";
// 	gpios = <&gpioa 2 GPIO_ACTIVE_LOW>;
// 	active-delay-ms = <1000>;
// 	timeout-ms = <3000>;
// };
/* USER CODE END addons */

